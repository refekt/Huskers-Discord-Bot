#!/usr/bin/env python3.7
import discord
from discord.ext import commands
import requests
import sys
import random
import json
import config
import crystal_balls
import time


botPrefix = '$'
client = commands.Bot(command_prefix=botPrefix)
player_search_list = [] #initialize a global list for crootbot to put search results in
player_search_list_len = 0 # length storage
emoji_list = ['1âƒ£', '2âƒ£', '3âƒ£', '4âƒ£', '5âƒ£', '6âƒ£', '7âƒ£', '8âƒ£', '9âƒ£', 'ðŸ”Ÿ']


with open('team_ids.json', 'r') as fp:
    team_ids = json.load(fp)


long_positions = {'PRO' : 'Pro-Style Quarterback',
                  'DUAL': 'Dual-Threat Quarterback',
                  'APB' : 'All-Purpose Back',
                  'RB' : 'Running Back',
                  'FB' : 'Fullback',
                  'WR' : 'Wide Receiver',
                  'TE' : 'Tight End',
                  'OT' : 'Offensive Tackle',
                  'OG' : 'Offensive Guard',
                  'OC' : 'Center',
                  'SDE' : 'Strong-Side Defensive End',
                  'WDE' : 'Weak-Side Defensive End', 
                  'DT' : 'Defensive Tackle',
                  'ILB' : 'Inside Linebacker', 
                  'OLB' : 'Outside Linebacker',
                  'CB' : 'Cornerback',
                  'S' : 'Safety',
                  'ATH' : 'Athlete',
                  'K' : 'Kicker',
                  'P' : 'Punter', 
                  'LS' : 'Long Snapper',
                  'RET' : 'Returner'
                  }


@client.event
async def on_ready():
    print("Logged in as {0}. Discord.py version is: [{1}] and Discord version is [{2}]".format(client.user, discord.__version__, sys.version))
    # print("The client has the following emojis:\n", client.emojis)


@client.event
async def on_message(message):
    """ Commands processed as messages are entered """

    if not message.author.bot:
        # Good bot, bad bot
        if "good bot" in message.content.lower():
            await message.channel.send("OwO thanks")
        elif "bad bot" in message.content.lower():
            embed = discord.Embed(title="I'm a bad, bad bot")
            embed.set_image(url='https://i.imgur.com/qDuOctd.gif')
            await message.channel.send(embed=embed)
        # Husker Bot hates Isms
        if "isms" in message.content.lower():
            dice_roll = random.randint(1,101)
            if dice_roll >= 90:
                await message.channel.send("Isms? That no talent having, no connection having hack? All he did was lie and "
                                           "make **shit** up for fake internet points. Iâ€™m glad heâ€™s gone.")
        # Add Up Votes and Down Votes
        if (".addvotes") in message.content.lower():
            # Upvote = u"\u2B06" or "\N{UPWARDS BLACK ARROW}"
            # Downvote = u"\u2B07" or "\N{DOWNWARDS BLACK ARROW}"
            emojiUpvote = "\N{UPWARDS BLACK ARROW}"
            emojiDownvote = "\N{DOWNWARDS BLACK ARROW}"
            await message.add_reaction(emojiUpvote)
            await message.add_reaction(emojiDownvote)

    # Working with crootbot
    if message.author == client.user and 'Search Results:' in message.content and player_search_list:
        # Pre-add reactions for users
        i = 0
        while i < len(player_search_list):
            await message.add_reaction(emoji_list[i])
            i += 1


    # HUDL highlight puller on react. This section is to take the crootbot message, find if a hudl profile exists, and pull the video. 
    # Next would be to monitor reactions and post the video if someone reacted to the video camera emoji.
    # TODO If there are multiple football players with the same name we may get the wrong guy. Especially for croots from previous classes. We will want to add more logic to narrow 
    # it down even more 
    if len(message.embeds) > 0:
        if message.author == client.user and message.embeds[0].footer.text == 'CrootBot message generated by Husker Discord Bot':
            url = 'https://www.hudl.com/api/v3/community-search/feed-users/search'
            headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'}
            embed_field_name = message.embeds[0].fields[0].name.split()
            croot_name = embed_field_name[0] + ' ' + embed_field_name[1]
            croot_name = croot_name.replace('*', '')
            payload = {'query' :  croot_name}
            page = requests.post(url = url, headers = headers, params = payload)
            data = json.loads(page.text)
            results = data['results']
            matching_players = []
            for r in results:
                if r['name'] == croot_name and r['primaryTeam']['teamName']=='Boys Varsity Football':
                    matching_players.append(r)
     
            if len(matching_players) > 0:
                global hudl_url       
                hudl_url = 'https://www.hudl.com' + matching_players[0]['url']
                page = requests.get(url = hudl_url, headers = headers)
                
                embed_old = message.embeds[0]
                embed_new = embed_old.set_footer(text = 'Click the video camera emoji to get the most-viewed Hudl highlight for this recruit') 
                await message.edit(embed = embed_new)
                await message.add_reaction('ðŸ“¹')

    # Always need this
    await client.process_commands(message)


@client.event
async def on_reaction_add(reaction, user):
    # print(reaction.emoji)
    if user != client.user and reaction.message.author == client.user and 'Search Results:' in reaction.message.content and player_search_list:
        channel = reaction.message.channel
        emoji_dict = {'1âƒ£' : 0,
                      '2âƒ£' : 1,
                      '3âƒ£' : 2,
                      '4âƒ£' : 3,
                      '5âƒ£' : 4,
                      '6âƒ£' : 5,
                      '7âƒ£' : 6, 
                      '8âƒ£' : 7, 
                      '9âƒ£' : 8, 
                      'ðŸ”Ÿ' : 9
                      }
        if reaction.emoji in emoji_dict:
            await parse_search(search = player_search_list[emoji_dict[reaction.emoji]], channel = channel)

    if user != client.user and reaction.message.author == client.user and reaction.message.embeds[0].footer.text == 'Click the video camera emoji to get the most-viewed Hudl highlight for this recruit':
        if reaction.emoji == 'ðŸ“¹':
            channel = reaction.message.channel
            await hudl_highlight(channel)
        
        
# Catch invalid commands/errors
@client.event
async def on_command_error(ctx, error):
    output_msg = "Whoa there {}! Something went wrong. {}. Please review `$help` for a list of all available commands.".format(ctx.message.author, error)
    await ctx.send(output_msg)


@client.command()
async def crootbot(ctx):
    #pulls a json file from the 247 advanced player search API and parses it to give
    #info on the croot.
    #First, pull the message content, split the individual pieces, and make the api call
    croot_info = ctx.message.content.strip().split()
    # Added error handling to prevent bad inputs, not perfect doesn't check each value
    # [0] should be $crootbot
    # [1] should be a 4 digit int
    # [2] should be a string
    # [3] should be a string
    # print(croot_info, len(croot_info))
    if len(croot_info) != 4:
        await ctx.send("Invalid syntax. The proper format is `$crootbot <year> <full name>`.")
        return
    year = int(croot_info[1])
    first_name = croot_info[2]
    last_name = croot_info[3]
    url = 'https://247sports.com/Season/{}-Football/Recruits.json?&Items=15&Page=1&Player.FirstName={}&Player.LastName={}'.format(year, first_name, last_name)
    headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'}
    search = requests.get(url=url, headers=headers)
    search = json.loads(search.text)
    if not search:
        await ctx.send("I could not find any player named {} {} in the {} class".format(first_name, last_name, year))
    elif len(search) > 1:
        global player_search_list
        players_string = ('''There were multiple matches for {} {} in the {} class. Please react with the corresponding emoji to the player you\'d 
like to see CrootBot results for.\n Search Results:\n''').format(first_name, last_name, year)
        players_list = []
        player_search_list = search       
        player_search_list_len = range(min(10,len(search)))
        for i in range(min(10, len(search))):
            player = search[i]['Player']
            first_name = player['FirstName']
            last_name = player['LastName']
            position = player['PrimaryPlayerPosition']['Abbreviation']
            if position in long_positions:
                position = long_positions[position]
            players_string += '{}: {} {} - {}\n'.format(emoji_list[i], first_name, last_name, position)
            players_list.append(['FirstName', 'LastName'])
        await ctx.send(players_string)
        # new_message = client.
        # i = 0
        # Pre-add reactions for users
        # while i < range(min(10, len(search))):
            # await ctx.message.add_reaction(emoji_list[i])
            # i += 1

    else:
        channel = ctx.channel
        await parse_search(search[0], channel) #The json that is returned is a list of dictionaries, I pull the first item in the list (may consider adding complexity)

async def parse_search(search, channel):
        year = search['Year']
        player = search['Player']
        first_name = player['FirstName']
        last_name = player['LastName']
        position = player['PrimaryPlayerPosition']['Abbreviation']
        if position in long_positions:
            position = long_positions[position]
        hometown = player['Hometown']
        state = hometown['State']
        city = hometown['City']
        height = player['Height'].replace('-', "'") + '"'
        weight = player['Weight']
        high_school = player['PlayerHighSchool']['Name']
        image_url = player['DefaultAssetUrl']
        composite_rating = player['CompositeRating']
        if composite_rating is None:
            composite_rating = 'N/A'
        else:
            composite_rating = player['CompositeRating']/100
        composite_star_rating = player['CompositeStarRating']
        national_rank = player['NationalRank']
        if national_rank is None:
            national_rank = 'N/A'
        position_rank = player['PositionRank']
        if position_rank is None:
            position_rank = 'N/A'
        state_rank = player['StateRank']
        if state_rank is None:
            state_rank = 'N/A'
        player_url = player['Url']
        stars = ''
        for i in range(int(composite_star_rating)):
            stars += '\N{WHITE MEDIUM STAR}'
            
        #Check if they are committed. It's a little different with signed players.
        commit_status = search['HighestRecruitInterestEventType']
        if commit_status == 'HardCommit' or commit_status == 'SoftCommit':
            commit_status = 'Committed'
        else:
            commit_status = 'Uncommitted'
        if type(search['SignedInstitution']) is int:
            commit_status = 'Signed'  
        title = '**{} {}** - {}\n'.format(first_name, last_name, stars) 
        
        #Now that composite rating can be str or float, we need to handle both cases. Also, don't want the pound sign in front of N/A values.
        if type(composite_rating) is str:
            body = '**{}, Class of {}**\n{}, {}lbs -- From {}, {}({})\n247 Composite Rating: {}\n'.format(position, year, height, int(weight), city, state, high_school, composite_rating)
            rankings = '__Rankings__\nNational: {}\nState: {}\nPosition: {}\n247 Link - {}\n'.format(national_rank, state_rank, position_rank, player_url)
        else:
            body = '**{}, Class of {}**\n{}, {}lbs -- From {}, {}({})\n247 Composite Rating: {:.4f}\n'.format(position, year, height, int(weight), city, state, high_school, composite_rating)
            rankings = '__Rankings__\nNational: #{}\nState: #{}\nPosition: #{}\n247 Link - {}\n'.format(national_rank, state_rank, position_rank, player_url)
        
        #Create a recruitment status string. If they are committed, use our scraped json team_ids dictionary to get the team name from the id in the committed team image url.
        #I've found that if a team does not have an image on 247, they use a generic image with 0 as the id. Also if the image id is not in the dictionary, we want to say Unknown.
        recruitment_status = 'Currently {}'.format(commit_status)
        if commit_status == 'Committed' or commit_status == 'Signed':
            school_id = str(search['CommitedInstitutionTeamImage'].split('/')[-1].split('.')[0])
            if school_id == '0' or school_id not in team_ids:
                school = 'Unknown'
            else:
                school = team_ids[school_id]
            if school == 'Nebraska':
                school += ' ðŸ’¯:corn::punch:'
            recruitment_status += ' to {}'.format(school)
        recruitment_status = '**' + recruitment_status + '**'
            
        crootstring = body + rankings + recruitment_status        
        message_embed = discord.Embed(name = "CrootBot", color = 0xd00000)
        message_embed.add_field(name = title, value = crootstring, inline = False)
        #Don't want to try to set a thumbnail for a croot who has no image on 247
        if image_url != '/.':
            message_embed.set_thumbnail(url = image_url)
        await channel.send(embed=message_embed)
        
        global player_search_list
        player_search_list = []

async def hudl_highlight(channel):
    """This function takes the current global hudl_url variable and posts the most viewed highlight video from that profile"""
    url = hudl_url
    headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'}
    #The original hudl url redirects, so we want to request the page, then get the new url after the redirect
    page = requests.get(url = url, headers = headers)
    url = page.url + '/videos'
    page = requests.get(url = url, headers = headers)
    soup = BeautifulSoup(page.text, 'html.parser')
    # This fucking shit. To avoid using a webdriver, we have to take the direct request and find the script section that corresponds to the script that pulls the
    # profile details, then find the video in the resulting dictionary. Took so much bs to find this
    data = json.loads(soup.find_all('script')[4].get_text()[soup.find_all('script')[4].get_text().find('{'):-1])
    reels = data['model']['highlights']['reels']
    # Initialize our target url as the first video in the returned list, then search through the list and find the video with the most views. 
    video_url = data['model']['highlights']['reels'][0]['videoUrl']
    video_views = data['model']['highlights']['reels'][0]['views']
    for r in reels:
        if r['views'] > video_views:
            views = r['views']
            video_url = r['videoUrl']
    await channel.send('https://www.hudl.com' + video_url)
    
@client.command()
async def billyfacts(ctx):
    """ Real facts about Bill Callahan """
    facts = []
    with open("facts.txt") as f:
        for line in f:
            facts.append(line)
    f.close()

    random.shuffle(facts)
    await ctx.message.channel.send(random.choice(facts))


@client.command()
async def randomflag(ctx):
    """ A random ass, badly made Nebraska flag """
    flags = []
    with open("flags.txt") as f:
        for line in f:
            flags.append(line)
    f.close()

    random.shuffle(flags)
    embed = discord.Embed(title="Random Ass Nebraska Flag")
    embed.set_image(url=random.choice(flags))
    await ctx.send(embed=embed)


@client.command()
async def crappyiowaflag(ctx):
    await ctx.send("In honor of {}, behold this crappy flag:".format('<@440885775132000266>'))
    await ctx.send('https://i.imgur.com/xxs49sF.png')


@client.command()
async def iowasux(ctx):
    """ Iowa has the worst corn """
    await ctx.message.channel.send("You're god damn right they do, {0}!".format(ctx.message.author))
    emoji = client.get_emoji(441038975323471874)
    await ctx.message.add_reaction(emoji)
    await ctx.message.channel.send(emoji)


@client.command()
async def stonk(ctx):
    """ Isms hates stocks """
    await ctx.send("Stonk!")


@client.command()
async def potatoes(ctx):
    """ Potatoes are love; potatoes are life """
    embed = discord.Embed(title="Po-Tay-Toes")
    embed.set_image(url='https://i.imgur.com/Fzw6Gbh.gif')
    await ctx.send(embed=embed)


@client.command()
async def flex(ctx):
    """ S T R O N K """
    embed = discord.Embed(title="FLEXXX ðŸ˜©")
    embed.set_image(url='https://i.imgur.com/92b9uFU.gif')
    await ctx.send(embed=embed)

@client.command()
async def shrug(ctx):
    """ Who knows ðŸ˜‰ """
    embed = discord.Embed(title="ðŸ¤·â€â™€ï¸")
    embed.set_image(url='https://i.imgur.com/Yt63gGE.gif')
    await ctx.send(embed=embed)


@client.command()
async def ohno(ctx):
    """ This is not ideal """
    embed = discord.Embed(title="Big oof")
    embed.set_image(url='https://i.imgur.com/f4P6jBO.png')
    await ctx.send(embed=embed)


@client.command()
async def bigsexy(ctx):
    """ Give it to me Kool Aid man """
    embed = discord.Embed(title="OOOHHH YEAAHHH ðŸ˜©")
    embed.set_image(url='https://i.imgur.com/UpKIx5I.png')
    await ctx.send(embed=embed)


@client.command()
async def whoami(ctx):
    """ OH YEAH! """
    embed = discord.Embed(title="OHHH YEAAAHHH!!")
    embed.set_image(url='https://i.imgur.com/jgvr8pd.gif')
    await ctx.send(embed=embed)


@client.command()    
async def huskerbotquit(ctx):
    """ Did HuskerBot act up? Use this only in emergencies. """
    print("HuskerBot was terminated by {}.".format(ctx.message.author))
    await client.logout()


@client.command()
async def recentballs(ctx, number=0):
    """ Send the last 1-5 crystal ball predictions from Steve Wiltfong. Usage is $recent_balls [1-5]"""
    # Error handling
    # Random number of 5 to prevent spam
    if number > 5:  # len(crystal_balls.cb_list):
        await ctx.send("The number of retrieved Crystal Balls must be less than 5.")
        return

    limitSpam = -1

    if number > 0:
        number -= 1

    for cbs in crystal_balls.cb_list:
        # print("Number : {} >= limitSpam : {}".format(number, limitSpam))
        if limitSpam >= number:
            return

        varPhoto = cbs['Photo']
        varName = cbs['Name']
        varPrediction = cbs['Prediction']
        varPredictionDate = cbs['PredictionDate']
        varProfile = cbs['Profile']
        varResult = cbs['Result']
        varTeams = dict(cbs['Teams'])
        varTeamString = ""

        for x, y in varTeams.items():
            varTeamString += '{} : {}\n'.format(x, y)
        embed = discord.Embed(title="Steve Wiltfong Crystal Ball Predictions", color=0xff0000)
        embed.set_thumbnail(url=varPhoto)
        embed.add_field(name="Player Name", value=varName, inline=False)
        embed.add_field(name="Prediction", value=varPrediction, inline=True)
        embed.add_field(name="Prediction Date/Time", value=varPredictionDate, inline=True)
        embed.add_field(name="Result", value=varResult, inline=False)
        embed.add_field(name="Predicted Teams", value=varTeamString, inline=True)
        embed.add_field(name="247Sports Profile", value=varProfile, inline=False)
        embed.set_footer(text="Generated by Husker Discord CrootBot")
        await ctx.send(embed=embed)

        limitSpam += 1

# Run the Discord bot
client.run(config.DISCORD_TOKEN)
